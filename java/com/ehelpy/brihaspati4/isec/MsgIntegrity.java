package com.ehelpy.brihaspati4.isec;

import java.security.InvalidKeyException;
import java.security.Key;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Signature;
import java.security.SignatureException;
import java.security.cert.Certificate;
import java.util.Arrays;

import javax.crypto.Mac;

/**
 * <b>Message Integrity - protect integrity of messages between nodes</b><br>
 * Message Digest - Can be verified by anyone <br>
 * Message Authentication Code - Requires sharing of a secret key for integrity verification
 * <p>
 * NOTE - except standard algorithms (PUBLIC_CONST), every other algorithm has a 
 * potential of generating NoSuchAlgorithmException.
 * <p>
 * Every implementation of Java platform is required to support the following standard algorithms - <br>
 * <ul>
 *  <li>Digest - MD5, SHA-1, SHA-256</li>
 *  <li>HMAC   - MD5, SHA-1, SHA-256</li>
 *  <li>Sign   - SHA1-DSA, SHA256-DSA, SHA1-RSA, SHA256-RSA</li>
 * </ul>
 * @author <a href="https://t.me/bishtsarthak">Sarthak Bisht</a>
 * @since 23rd Jan 2020
 */
public final class MsgIntegrity {
	private       static boolean newObj           = false;         // restricts creation of new instances

	/**
	 * message digest algorithm as per [RFC 1321 | Apr 1992]
	 */
	public  final static String  DGST_MD5         = "MD5";
	
	/**
	 * secure hash algorithm as per [FIPS 180-4 | Mar 2012]
	 */
	public  final static String  DGST_SHA_1       = "SHA-1";
	
	/**
	 * secure hash algorithm as per [FIPS 180-4 | Mar 2012]
	 */
	public  final static String  DGST_SHA_256     = "SHA-256";

	/**
	 * keyed hashing for message authentication as per [RFC 2104 | Feb 1997]
	 */
	public  final static String  HMAC_MD5         = "HmacMD5";
	
	/**
	 * keyed hashing for message authentication as per [RFC 2104 | Feb 1997]
	 */
	public  final static String  HMAC_SHA_1       = "HmacSHA1";
	
	/**
	 * keyed hashing for message authentication as per [RFC 2104 | Feb 1997]
	 */
	public  final static String  HMAC_SHA_256     = "HmacSHA256";
	
    /**
     * DSA algorithm using SHA-1 to create and verify digital signatures as per [FIPS 186-3 | Jun 2009]
     */
    public  final static String  SIGN_SHA_1_DSA   = "SHA1withDSA";
    
    /**
     * DSA algorithm using SHA-256 to create and verify digital signatures as per [FIPS 186-3 | Jun 2009]
     */
    public  final static String  SIGN_SHA_256_DSA = "SHA256withDSA";
    
    /**
     * RSA algorithm using SHA-1 digest with RSASSA-PKCS1-v1_5 signature scheme as per [RFC 8017 | Nov 2016]
     */
    public  final static String  SIGN_SHA_1_RSA   = "SHA1withRSA";
    
    /**
     * RSA algorithm using SHA-256 digest with RSASSA-PKCS1-v1_5 signature scheme as per [RFC 8017 | Nov 2016]
     */
    public  final static String  SIGN_SHA_256_RSA = "SHA256withRSA";	

	/**
	 * private constructor to enforce non-instantiability by external code
	 * @throws AssertionError ensures that constructor is NOT invoked accidently (by sub-class, reflection etc)
	 */
    private MsgIntegrity() throws AssertionError {if (MsgIntegrity.newObj == false) throw new AssertionError();}
	
	/**
	 * Use this function to generate digest of a single block of message.
	 * @param message byte array to be digested.
	 * @param algorithm the name of the algorithm requested. It is recommended to use MsgIntegrity.DGST_* algorithms.
	 * @return digest the array of bytes for the resulting hash value.
	 * @throws NoSuchAlgorithmException if no Provider supports a MessageDigestSpi implementation for the specified algorithm
	 */
	public static byte[] getDigest(byte[] message, String algorithm) 
			throws NoSuchAlgorithmException {
		MessageDigest mDigest = MessageDigest.getInstance(algorithm);
		return mDigest.digest(message);
	}
	
	/**
	 * Use this function to generate MAC digest of a single block of message.
	 * @param message byte array to be digested.
	 * @param algorithm the standard name of the requested MAC algorithm. It is recommended to use MsgIntegrity.HMAC_* algorithms.
	 * @param symmetricKey shared secret between MAC sender and reciever.
	 * @return digest the array of bytes and symmetricKey for the resulting hash value.
	 * @throws NoSuchAlgorithmException if no Provider supports a MacSpi implementation for the specified algorithm.
	 * @throws InvalidKeyException if the given key is inappropriate for initializing this MAC.
	 */
	public static byte[] getMacDigest(byte[] message, String algorithm, Key symmetricKey) 
			throws NoSuchAlgorithmException, InvalidKeyException {
		Mac mac = Mac.getInstance(algorithm);
		mac.init(symmetricKey);
		return mac.doFinal(message);
	}
	
	/**
	 * Use this function to sign a digest or MAC digest.
	 * @param digest generated by getDigest or getMacDigest.
	 * @param privateKey the private key of the identity whose signature is going to be generated.
	 * @param algorithm the standard name of the algorithm requested. It is recommended to use MsgIntegrity.SIGN_* algorithms.
	 * @return the signature bytes of the signing operation's result.
	 * @throws NoSuchAlgorithmException if no Provider supports a Signature implementation for the specified algorithm.
	 * @throws InvalidKeyException if the key is invalid.
	 * @throws SignatureException if this signature algorithm is unable to process the input data provided.
	 */
	public static byte[] getSignature(byte[] digest, PrivateKey privateKey, String algorithm) 
			throws NoSuchAlgorithmException, InvalidKeyException, SignatureException {
		Signature sign = Signature.getInstance(algorithm);
		SecureRandom sRandom = SecureRandom.getInstanceStrong();
		sign.initSign(privateKey, sRandom);
		sign.update(digest);
		return sign.sign();
	}
	
	/**
	 * Use this function to compare digest/MAC digest values
	 * @param digest_1 one byte array to be tested for equality
	 * @param digest_2 the other byte array to be tested for equality
	 * @return true if the two arrays are equal
	 */
	public static boolean compareDigest(byte[] digest_1, byte[] digest_2) {
		return Arrays.equals(digest_1, digest_2);
	}
	
	/**
	 * Use this function to verify a signature using public key
	 * @param digest generated by getDigest or getMacDigest.
	 * @param signature the signature bytes to be verified.
	 * @param publicKey the public key of the identity whose signature is going to be verified.
	 * @param algorithm the standard name of the algorithm requested. It is recommended to use MsgIntegrity.SIGN_* algorithms.
	 * @return true if the signature was verified, false if not.
	 * @throws NoSuchAlgorithmException if no Provider supports a Signature implementation for the specified algorithm.
	 * @throws InvalidKeyException if the key is invalid.
	 * @throws SignatureException the passed-in signature is improperly encoded or of the wrong type, 
	 * if this signature algorithm is unable to process the input data provided, etc.
	 */
	public static boolean verifySignature(byte[] digest, byte[] signature, PublicKey publicKey, String algorithm) 
			throws NoSuchAlgorithmException, InvalidKeyException, SignatureException {
		Signature sign = Signature.getInstance(algorithm);
		sign.initVerify(publicKey);
		sign.update(digest);
		return sign.verify(signature);
	}
	
	/**
	 * Use this function to verify a signature using certificate
	 * @param digest generated by getDigest or getMacDigest.
	 * @param signature the signature bytes to be verified.
	 * @param certificate the certificate of the identity whose signature is going to be verified.
	 * @param algorithm the standard name of the algorithm requested. It is recommended to use MsgIntegrity.SIGN_* algorithms.
	 * @return true if the signature was verified, false if not.
	 * @throws NoSuchAlgorithmException if no Provider supports a Signature implementation for the specified algorithm.
	 * @throws InvalidKeyException if the key is invalid.
	 * @throws SignatureException the passed-in signature is improperly encoded or of the wrong type, 
	 * if this signature algorithm is unable to process the input data provided, etc.
	 */
	public static boolean verifySignature(byte[] digest, byte[] signature, Certificate certificate, String algorithm) 
			throws NoSuchAlgorithmException, InvalidKeyException, SignatureException {
		Signature sign = Signature.getInstance(algorithm);
		sign.initVerify(certificate);
		sign.update(digest);
		return sign.verify(signature);
	}
	
}
